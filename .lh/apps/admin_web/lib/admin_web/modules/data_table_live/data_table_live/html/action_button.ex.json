{
    "sourceFile": "apps/admin_web/lib/admin_web/modules/data_table_live/data_table_live/html/action_button.ex",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1658039721430,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1658039721430,
            "name": "Commit-0",
            "content": "defmodule DataTableLive.HTML.ActionButton do\n  @moduledoc \"\"\"\n  For the actions buttons such as :new, :edit etc, as well as custom buttons.\n\n  Custom buttons can be added to the list in :action_buttons\n\n  ## Example\n\n  ```elixir\n    action_buttons: [:new, :edit, :super_cool_custom_action]\n  ```\n\n  You can then define the function called for that action in the module where the table is defined.\n  Don't forget to add your csrf_token.\n\n  ```elixir\n    def super_cool_custom_action(socket, item, csrf_token) do\n      link \"SUPER AWESOME\", to: Routes.super_cool_path(socket, :custom_action, item), \"data-confirm\": \"Are you sure?\", csrf_token: csrf_token\n    end\n  ```\n  \"\"\"\n\n  alias DataTableLive.{Params, Text}\n  alias Phoenix.HTML.Link\n\n  @typedoc \"Controller action\"\n  @type action :: :new | :delete | :show | :edit\n\n  @doc \"Builds an individual button, takes an atom representing the action, and the assigns map\"\n  @spec build(:new, map) :: {:safe, iolist}\n  @spec build(action, atom, map) :: {:safe, iolist}\n  def build(\n        :new,\n        %{\n          socket: socket,\n          params:\n            %Params{\n              parent: nil,\n              routes: routes,\n              path: path,\n              action_buttons: action_buttons\n            } = params\n        }\n      ) do\n    if Enum.member?(action_buttons, :new) do\n      [socket, :new]\n      |> then(&apply(routes, path, &1))\n      |> html(:new, params)\n    else\n      {:safe, [\"\"]}\n    end\n  end\n\n  def build(\n        :new,\n        %{\n          socket: socket,\n          params:\n            %Params{\n              parent: parent,\n              routes: routes,\n              path: path,\n              action_buttons: action_buttons\n            } = params\n        }\n      ) do\n    if Enum.member?(action_buttons, :new) do\n      [socket, :new, parent]\n      |> then(&apply(routes, path, &1))\n      |> html(:new, params)\n    else\n      {:safe, [\"\"]}\n    end\n  end\n\n  @doc false\n  def build(\n        :delete,\n        entry,\n        %{socket: socket, params: %Params{belongs_to: nil, routes: routes, path: path} = params}\n      ) do\n    [socket, :delete, entry]\n    |> then(&apply(routes, path, &1))\n    |> html(:delete, params)\n  end\n\n  def build(\n        :delete,\n        entry,\n        %{socket: socket, params: %Params{routes: routes, path: path} = params}\n      ) do\n    [socket, :delete, parent_for(entry, params), entry]\n    |> then(&apply(routes, path, &1))\n    |> html(:delete, params)\n  end\n\n  def build(\n        :show,\n        entry,\n        %{socket: socket, params: %Params{belongs_to: nil, routes: routes, path: path} = params}\n      ) do\n    [socket, :show, entry]\n    |> then(&apply(routes, path, &1))\n    |> html(:show, params)\n  end\n\n  def build(\n        :show,\n        entry,\n        %{socket: socket, params: %Params{routes: routes, path: path} = params}\n      ) do\n    [socket, :show, parent_for(entry, params), entry]\n    |> then(&apply(routes, path, &1))\n    |> html(:show, params)\n  end\n\n  def build(\n        :edit,\n        entry,\n        %{socket: socket, params: %Params{belongs_to: nil, routes: routes, path: path} = params}\n      ) do\n    [socket, :edit, entry]\n    |> then(&apply(routes, path, &1))\n    |> html(:edit, params)\n  end\n\n  def build(\n        :edit,\n        entry,\n        %{socket: socket, params: %Params{routes: routes, path: path} = params}\n      ) do\n    [socket, :edit, parent_for(entry, params), entry]\n    |> then(&apply(routes, path, &1))\n    |> html(:edit, params)\n  end\n\n  # For custom actions such as archive\n  def build(custom_action, entry, %{module: module, socket: socket, csrf_token: csrf_token}) do\n    apply(module, custom_action, [socket, entry, csrf_token])\n  end\n\n  @spec html(String.t(), action, Params.t()) :: {:safe, iolist}\n  defp html(route, :new, %Params{} = params) do\n    params\n    |> Text.text(:new)\n    |> Link.link(to: route, class: \"exz-action-new\")\n  end\n\n  defp html(route, :show, %Params{} = params) do\n    params\n    |> Text.text(:show)\n    |> Link.link(to: route, class: \"exz-action-show\")\n  end\n\n  defp html(route, :edit, %Params{} = params) do\n    params\n    |> Text.text(:edit)\n    |> Link.link(to: route, class: \"exz-action-edit\")\n  end\n\n  defp html(route, :delete, %Params{csrf_token: csrf_token} = params) do\n    params\n    |> Text.text(:delete)\n    |> Link.link(\n      to: route,\n      class: \"exz-action-delete\",\n      method: :delete,\n      \"data-confirm\": Text.text(params, :confirm_action),\n      csrf_token: csrf_token\n    )\n  end\n\n  @doc \"Gets the parent that the nested resource belongs to\"\n  @spec parent_for(map, Params.t()) :: struct\n  def parent_for(entry, %Params{belongs_to: belongs_to}) do\n    case Map.get(entry, belongs_to) do\n      nil -> raise \"You need to select the association in :belongs_to\"\n      result when is_struct(result) -> result\n    end\n  end\nend\n"
        }
    ]
}